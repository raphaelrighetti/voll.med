Quando vamos inicializar um projeto Spring, não precisamos necessariamente usar o Spring Initializr, podemos criar um projeto Maven do zero e ir adicionando as dependências manualmente, e fazendo a estrutura necessária do projeto.

============spring-boot-starter-parent============

"parent", quando se trata do pom.xml, é um arquivo pom.xml pai que pode ser herdado. Para fazer essa herança, basta colocarmos as informações do pom.xml que queremos como pai no nosso pom.xml alvo envolta de uma tag 

  <parent>
    </>
  </parent>.

No entanto, quando se trata do spring-boot-starter-parent, devemos tratar ele como uma dependência.

============spring-boot-starter============

É a dependência mais básica do Spring Boot, que traz com ela o "core" do Spring Boot.

============spring-boot-maven-plugin============

É um plugin que colocamos na tag de build, e irá servir para fazer o build com todas as dependências corretamente.

============RODAR APLICAÇÃO SPRING BOOT============

A classe principal que vai rodar a nossa aplicação Spring, por convenção, sempre terá o nome do nosso artefato e terminará com Application.

Essa classe é a classe executável, ou seja, temos que ter um método main dentro dela.

Para o Spring saber que aquela é a classe principal da aplicação, devemos marcá-la com a annotation @SpringBootApplication.

No nosso método main devemos executar o método SpringApplication.run(<nome da classe main>.class, args);

============Spring x Spring Boot============

Spring é um framework dividido em módulos, com a ideia de que você só usará os módulos conforme a necessidade do projeto. Ele existe desde 2002, mas na época era preciso criar configurações extensas em XML ou uma classe Java para configurar cada módulo e cada coisa que voce ia utilizar. Foi para combater isso que o Spring Boot nasceu, tornando a tarefa de criar configurações automática e muito mais rápida e de fácil manutenção.

O Spring Boot não vem como uma dependência, mas sim na tag parent, que funciona como uma herança para outro pom.xml.

O Spring Boot inverteu o fluxo de rodar aplicações web Java, fazendo termo o servidor Tomcat na nossa aplicação, e não o contrário, por isso conseguimos rodar a aplicação apenas executando a nossa classe com o método main que chama o método run do SpringApplication.

============Spring Dev Tools============

Funciona como um live-server.

Para utilizarmos no IntelliJ, precisamos marcar a opção "build automatically" e a opção de "allow auto-run mesmo quando a aplicação estiver rodando" no compiler, pois apenas ter a dependência não é o suficiente.

============@RestController============

É a annotation que especifica que nossa classe é um controlador REST.

Precisa ter a annotation @RequestMapping, que passa o caminho inicial da requisição, como "/", por exemplo.

============@GetMapping============

Define que o método no RestController vai ser chamado por requisições GET.

Existem outras anotações no mesmo padrão para os demais métodos HTTP.

============REQUEST BODY============

O corpo da requisição no Spring nada mais é do que um parâmetro do método que vai ser chamado na requisição. Porém, para o Spring entender que aquele parâmetro deve receber o corpo da requisição, precisamos marcá-lo com a annotation @RequestBody.

============CORS Spring============

Para acessarmos nossa API de origens diferentes, precisamos criar uma classe de configuração que irá definir as origens permitidas e os métodos HTTP permitidos a partir dessas origens. A classe deverá ficar mais ou menos assim:

@Configuration
public class CorsConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "TRACE", "CONNECT");
    }
}

============DTO============

Data Transfer Objects são um padrão de objetos feitos para representar os dados de entrada e saída de requisições na nossa API. Sempre iremos utilizar esse padrão.

Nas versões mais recentes do Java, utilizamos Records para representar esses DTOs.

============RECORDS============

Record é um tipo de classe específico das versões mais recentes do Java, que são classes imutáveis de dados, onde não precisamos criar atributos nem métodos para termos as funções de get e etc.

============ADICIONANDO DEPENDÊNCIAS============

Podemos pegar as dependências diretamente do Spring Initializr indo na aba EXPLORE, que irá mostrar como o pom.xml será gerado, assim podendo copiar exatamente as dependências do jeito certo.

============ Spring Data JPA============

Spring Data JPA é o módulo do Spring que nos permite trabalhar com o JPA para a persistência dos dados, fazendo a conexão com o banco de dados e já usando o Hibernate como ORM.

Assim que adicionamos a dependência no nosso projeto, ele tentará fazer a conexão com o banco de dados, gerando uma falha se não conseguir. Para especificarmos os parâmetros de conexão, temos que mexer no nosso arquivo application.properties, que é onde colocaremos as properties usadas na nossa aplicação.

temos que passar as propriedades de forma específica, o que é meio difícil de decorar no começo, mas vou listar as de conexão com banco aqui:

- spring.datasource.url=<conexão> (usa driver jdbc)
- spring.datasource.username=<username>
- spring.datasource.password=<password>

Podemos usar YAML também, o que facilita o uso de informações externas, o que ajuda no caso de querermos ocultar a conexão ao banco, por exemplo.

Algumas annotations do JPA que podemos utilizar:

- @Table(name = <nome da tabela>): especifica a tabela que estará mapeada com a entidade.
- @Entity(name = <nome>): especifica que a classe é uma entidade JPA, que estará linkada com uma entidade do nosso banco de dados.
- @Id: especifica que é uma chave de uma entidade (PK, FK)
- @GeneratedValue(strategy = GenerationType.IDENTITY): é uma annotation que especifica que aquele valor será gerado automaticamente pelo JPA. Passando uma strategy que irá dizer o tipo de geração automáticaque irá ser utilizada. No caso de um @Id, será IDENTITY.
- @Enumerated(EnumType.STRING): especifica que o atributo será um enum, também passando o tipo do Enum (String, nesse caso).
- @Embedded: usamos quando temos outra entidade dentro da nossa entidade, mas não queremos fazer um relacionamento, e sim que os atributos da outra entidade apareçam na mesma entidade.
- @Embeddable: especifica que a classe vai ser usada com @Embedded.

É importante lembrar que, mesmo tendo a annotation @Table na nossa entidade, se a tabela não existir, o JPA não irá criá-la automaticamente, o que irá gerar uma Exception.

Normalmente fazemos o link com o banco de dados usando objetos DAO (Data Access Object), que vem da ideia de separarmos as regras de negócio das regras de acesso ao banco de dados, criando um objeto específico para isso e não deixando isso junto com controllers e etc., mas o Spring facilita isso e fazemos o uso de interfaces (repositories).

Exemplo de uso dos DAOs:

public class ProdutoDao {

    private final EntityManager entityManager;

    public ProdutoDao(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public void create(Produto produto) {
        entityManager.persist(produto);
    }

    public Produto read(Long id) {
        return entityManager.find(Produto.class, id);
    }

    public void update(Produto produto) {
        entityManger.merge(produto);
    }

    public void remove(Produto produto) {
        entityManger.remove(produto);
   }

}

Assim que faríamos a persistência no banco de dados usando apenas o JPA, e não o Spring Data JPA.

Um repositório é uma interface que podemos utilizar nas nossas regras de negócio e lógicas para fazer a persistência dos dados. Agora, inserir lógicas, tratamento de dados, ou acesso direto sem um controller ao nosso repositório é algo que nunca devemos fazer, pois assim como o DAO, os repositórios também servem para fazermos essa divisão, apesar de ficarem mais próximos das lógicas do que os DAOs.
Também é interessante saber que um repositório pode tratar de um ou mais DAOs, assim podendo utilizar o mesmo repositório para entidades que possuem entidades como atributo.

O padrão Repository incentiva um design orientado a domínio, o que torna mais fácil a compreensão do domínio e da estrutura de dados, além de, no Spring, tornar o nosso código mais fácil e mais legível, a partir do uso das interfaces.

============JpaRepository============

É a interface mãe das interfaces Repository que precisamos criar para ter a persistência dos dados no banco de dados. Sempre criaremos uma interface para cada entidade nossa, usando a convençaõ de passar o nome da entidade com "Repository" no final.

Essas interfaces precisam estender a interface JpaRepository, que irá receber um generics com dois tipos após o "extends", onde o primeiro parâmetro é a entidade e o segundo o tipo do atributo @Id dela.

Só de criar a interface e estender JpaRepository, já temos o nosso repository pronto para ser utilizado, apesar de podemos criar outros métodos e também sobrescrever os existentes.

Para utilizar esse repository, precisamos ter um atributo na nossa classe controller que irá ser uma instância dele. Como não somos nós que fazemos a inicialização desse objeto, precisamos falar pro próprio Spring fazer isso com a annotation @Autowired, que é a annotation responsável por fazer a injeção de dependências no Spring.
Tendo esse objeto como atributo, podemos usar os métodos disponíveis nele dentro dos nossos métodos responsáveis por tratar as requisições, como, por exemplo, o método save();, responsável por salvar os dados no banco de dados.

Para instanciarmos uma entidade a partir de um DTO, precisamos de um construtor que recebe o DTO e passa os campos dele para a entidade (ou podemos usar o @AllArgsConstructor e passar os dados do DTO para ele no controller, mas isso é um saco).

============LOMBOK============

É uma biblioteca feita para utilizarmos annotations que geram códigos verbosos para nós, como getters e setters, toString e etc.

Algumas annotations:

- @Getter: gera os getters.
- @NoArgsConstructor: gera o construtor default.
- @AllArgsConstructor: gera um construtor com todos os atributos.
- @EqualsAndHashCode(of = <campo(s) usado(s) para fazer o HashCode>): gera o equals(); e o hash();, por padrão usando todos atributos para isso.

============FLYWAY MIGRATIONS============

Ferramentas de Migrations são ferramentas que nos dão o controle do versionamento do nosso banco de dados utilizado na aplicação. O FLYWAY é a ferramenta do Migrations que o Spring dá suporte, e ela servirá para fazermos todas as mudanças na estrutura do banco de dados que precisarmos, como criação de tabelas, modificação, exclusão, etc.

O FLYWAY não é um módulo do Spring, mas o Spring tem integração com ele, deixando mais fácil de utilizá-lo.

As migrations no Spring sempre ficam no diretório:

"src/main/java/resources/db/migration"

São arquivos .sql com scripts feitos por nós do que vai ser feito na migration.
(normalmente temos que criar o diretório "db/migration")

Sempre que formos mexer em migrations, devemos parar a nossa aplicação.

**MIGRATIONS EXECUTADAS NÃO PODEM SER MODIFICADAS**

Se precisamos fazer uma alteração, devemos criar outro arquivo de migration com um versionamento acima do anterior.

Se acontecer algum erro com a migration, devemos ir no banco de dados e executar o seguinte script:

"delete from flyway_schema_history where success = 0;"

Pode ser que alguma tabela ou atributo sejam criados em uma execução de migration com falha. Nesse caso, podemos apenas deletar o banco de dados e criá-lo novamente, que assim todas as migrations serão executadas do zero.

============PADRÃO NOMENCLATURA .sql FLYWAY============

Nos arquivos .sql do FLYWAY sempre temos que seguir o padrão de nomenclatura:

"V<número versionamento>__<nome descritivo>.sql"

Os scripts sql são executados automaticamente.

Os scripts sql são scripts sql normais, mudando conforme o banco de dados que estamos utilizando.

============@Transactional============

Precisamos dessa annotation em métodos de controladores que irão executar uma transação direta de dados com o nosso banco de dados, seja ela um create, um read, um update ou um delete.

============BEAN VALIDATION============

Bean Validation é uma especificação de validação do Java e o Spring tem um módulo chamado "Validation" que facilita o uso dessa especificação.

Precisamos fazer validações em parâmetros recebidos por requisições à nossa API, ou seja, precisamos fazer essas validações no DTO que irá guardar os dados recebidos no corpo da requisição.

A validação no Spring é feita por meio de annotations, o que torna muito mais fácil e legível fazer essas validações.
Temos que passar a annotation @Valid no método do controller que está recebendo o corpo da requisição para as verificações serem feitas.

Algumas annotations:

- @NotNull: especifica que o atributo não pode ser null.
- @NotBlank: especifica que o atributo não pode estar vazio, mesmo que não seja null (também não deixa ser null).
- @Email: especifica que a String deve estar no formato correto de um email.
- @Pattern(regexp = <regex>): especifica um padrão que a String deve seguir utilizando regex.
- @Valid: especifica que um atributo também tem que ser validado, e é usado no caso de termos outro DTO dentro do nosso DTO. Lembrando que temos que ter as validações dos campos no outro DTO também.

============REQUISIÇÕES GET============

Para darmos respostas à requisições GET, usamos a annotation @GetMapping no nosso controller. Podemos ter outro objeto DTO para devolver como resposta à requisição, devolvendo apenas os dados realmente necessários do nosso objeto que está sendo acessado.

Para pegarmos os registros do nosso banco de dados, podemos usar os métodos de "find" do nosso repository, que irão retornar um ou mais registros da nossa entidade, tendo o tipo do objeto como a classe da entidade.
Como temos que retornar uma coleção de objetos DTO, apenas usar esses métodos e tentar retornar o retorno deles na nossa resposta não dá certo, pois o tipo dos objetos retornados ainda não foi convertido para a nossa classe DTO. Para fazermos isso, podemos usar stream() e map():

"return repository.findAll().stream().map(MedicoDTOListagem::new).toList();"

Nesse exemplo, o map mapeia cada objeto do fluxo de dados para outro tipo, MedicoDTOListagem, nesse caso, usando o próprio construtor do record DTO como método, que recebe um objeto do tipo Medico, e transforma em uma lista desse tipo a partir da lista que tínhamos. 

Podemos ter construtores em Records, mas é importante lembrar que esses construtores personalizados sempre têm que usar o construtor padrão dos records, que é o construtor que recebe todos os atributos que declaramos na declaração do Record. Chamamos esse construtor da seguinte forma:

"this(<parâmetros recebidos no record...>);"

Sempre é bom usar DTOs, tanto para dados que estão sendo recebidos na API quanto para dados que estão sendo retornados por ela.

============PAGINAÇÃO============

Paginação é dividir o retorno das requisições get em páginas, devolvendo apenas um certo número de objetos por página.

O Spring já possui uma funcionalidade que faz essa paginação para nós, não precisamos implementar na mão. Essa funcionalidade está na interface Pageable, e podemos receber um objeto com esse tipo por parâmetro no nosso método.

Quando recebemos esse objeto, podemos passar ele como parâmetro do método findAll(); do repository, o que fará com que o nosso retorno não possa ser mais uma List, e sim uma Page.
O método findAll();, quando usado com um Pageable, já tem um método map(); que funciona do mesmo jeito que o map(); de Stream, mas já retornando uma Page que contém os objetos retornados, sem a necessidade de usarmos um método toList();, ou algo do tipo.

@GetMapping
public Page<MedicoDTOListagem> listar(Pageable pageable) {
    return repository.findAll(pageable).map(MedicoDTOListagem::new);
}

Quando utilizamos a paginação do Spring e implementamos nosso código dessa forma, a resposta da requisição virá de forma diferente, tendo os registros dentro de um array "content" e as informações sobre a paginação em um objeto "pageable", o que é útil para o front saber fazer melhor a paginação.

Por padrão, uma Page sempre terá 20 registros nela, mas podemos mudar isso utilizando os parâmetros "size=<número de registros na página>" e "page=<número da página a ser exibida>" como query string na requisição à nossa API. O índice das páginas começa no 0, assim como em listas. O Spring lê essa query string automaticamente.

============ORDENAÇÃO============

Por padrão, os registros sempre virão na mesma ordem em que eles foram inseridos no banco de dados, mas nós podemos mudar essa ordem utilizando recursos do Spring.

Para mudar a ordem dos registros retornados na requisição, basta colocarmos o parâmetro "sort=<atributo utilizado na ordem>,<asc ou desc>" na query string, assim fazendo a ordenação a partir de um atributo da nossa entidade, podendo escolher se queremos na ordem crescente ou decrescente com os parâmetros "asc" ou "desc" após a vírgula (por padrão é asc).

Podemos juntar parâmetros de ordenação e paginação na nossa query string sem problema algum. Exemplo:

"http://localhost:8080/medicos?size=10&page=0&sort=nome,asc"

============@PageableDefault============

Por padrão, o Spring irá usar o size de 20 registros e nenhum sort, mas podemos mudar isso com essa annotaion, usando ela da seguinte forma:

@PageableDefault(size = <int tamanho>, sort = {"<atributos>"})

Sim, podemos ordenar por mais de um atributo, por isso precisamos passar um array com os nomes dos atributos usados na ordenação (em String).

Também podemos mudar a ordem padrão da direção (asc ou desc) usando o parâmetro "direction = Sort.Direction.<ASC ou DESC>".

Se passarmos uma query string especificando esses comportamentos, essa query string irá sobrescrever o padrão especificado por nós.

Podemos mudar o nome dos parâmetros recebidos na query string pelo nosso arquivo "application.properties". Exemplo:

spring.data.web.pageable.page-parameter=pagina
spring.data.web.pageable.size-parameter=tamanho
spring.data.web.sort.sort-parameter=ordem

Podemos mostrar o sql gerado pelo Hibernate no console especificando que queremos isso no "application.properties" também.

============REQUISIÇÕES PUT============

É sempre uma boa prática retornar o campo de id dos nossos objetos em requisições GET, pois o front-end utilizará esse campo para mandar requisições PUT, DELETE, etc.

Para modificarmos um registro no nosso banco de dados, temos que modificar a nossa entidade JPA, que pegamos por meio do id, utilizando o método findById(); do repository, por meio de um objeto DTO com os campos que queremos permitir a alteração. Normalmente iremos criar um DTO novo, pois se usarmos um que já tínhamos feito, todas as validações que colocamos serão realizadas, o que não é bom, pois a maioria dos campos não devem ser obrigatórios em uma modificação.

Para a modificação realmente ocorrer, precisamos ter um método na nossa entidade que recebe o DTO de atualização e atualiza os campos com base nos campos passados, fazendo as validações nesse método mesmo. No método que irá responder à requisição PUT, devemos chamar esse método de atualização, sem nem chamar nenhum método do repository, pois só de ter as annotations @PutMapping e @Transactional, o Spring irá entender que se trata de uma atualização e irá atualizar os dados no banco de dados também.

============EXCLUSÃO LÓGICA============

Exclusão lógica é sinalizar no nosso banco de dados e no sistema que um usuário está inativo ao excluí-lo, em vez de realmente excluir o registro dele.

============REQUISIÇÕES DELETE============

Nas requisições DELETE, também utilizaremos o id da nossa entidade a ser deletada, mas não precisamos passar um corpo na requisição para isso, basta usarmos um parâmetro dinâmico na URL, que definimos na própria annotation @DeleteMapping dessa forma: @DeleteMapping("/{parametro}"). Para usarmos esse parâmetro recebido dentro do nosso método que responde às requisições DELETE, temos que receber um parâmetro no método com o mesmo nome que demos ao parâmetro na annotation e passar a annotation @PathVariable nele.

O código irá ficar mais ou menos assim:

@DeleteMapping("/{id}")
@Transactional
public void excluir(@PathVariable Long id) {
    repository.deleteById(id);
}

Dessa forma excluímos mesmo o registro do banco de dados, o que não é uma exclusão lógica.

============EXCLUSÃO LÓGICA COM DELETE============

Funciona basicamente da mesma forma que um PUT, pois só iremos mudar o campo de status para false (0 no banco de dados).

============FILTRAR LISTAGEM============

Se seguirmos o padrão de nomenclatura dos métodos do repository, basta criarmos um método novo na interface e ele já estará disponível para uso com uma lógica pronta checando o valor de algum atributo. Esse padrão é:

"findBy<Atributo><Valor>();" ("findByStatusTrue();", por exemplo)

============RETORNANDO STATUS CODE CORRETO============

Quando um método nosso retorna void, por padrão, o retorno que o Spring dará será um status 200 (ok) e nenhum corpo na resposta. Podemos mudar isso utilizando os métodos estáticos da classe ResponseEntity, que têm nomes descritivos com o tipo do status retornado. Por exemplo:

"return ResponseEntity.ok().build();"

Dessa forma, retornariamos um status 200 (ok).

Podemos definir que o retorno da ResponseEntity terá um corpo. Para isso, usamos Generics, colocando dentro dos sinais de menor e maior o objeto que vai ser o corpo da resposta. Por exemplo:

"ResponseEntity<Page<MedicoDTOListagem>>"

Para realmente retornar essa ResponseEntity contendo um corpo, basta passarmos como parâmetro no método estático que gera a ResponseEntity o objeto que queremos como corpo. Por exemplo:

"return ResponseEntity.ok(<objeto>).build();"

============201 CREATED============

O status code 201 (created) é o status code que deve ser retornado em requisições POST, que cadastraramalgum item no nosso sistema a partir da requisição. Além de retornar o status code 201, temos que retornar o novo registro com as informações cadastradas no corpo da resposta e um header chamado "Location", que irá especificar ao front-end onde aquele recurso está disponível na nossa API.

Para retornarmos um "ResponseEntity created" no Spring, precisamos usar o método:

"ResponseEntity.created(<URI>).body(<objeto>);"

Essa URI recebida como parâmetro no método created(); é a URI que vai ser utilizada no header "Location", e para gerá-la utilizamos a classe UriComponentsBuilder, que recebemos por parâmetro no nosso método. Código de exemplo para gerar a URI a partir da classe UriComponentsBuilder:

"uriBuilder.path("/medicos/{id}").buildAndExpand(medico.getId()).toUri();"

O que esse código faz é montar a URI com o caminho padrão da nossa API, sem termos que especificá-lo no código. Por exemplo, "http://localhost:8080/".

Importante lembrar que devemos gerar a URI após ter salvo o registro no banco de dados, pois se fazemos isso antes, a entidade que pegamos o id ainda não possui o id, já que esse é um valor gerado pela JPA quando salvamos a entidade no banco de dados.

No método body();, passamos um DTO de nossa escolha.

============DETALHAMENTO============

Já temos um CRUD completo na nossa API, mas normalmente isso não é o suficiente. Na maioria dos casos, também precisamos de algum método que detalhe um registro buscando-o por id.

Para fazer isso é bem simples, basta acessarmos o registro desejado por meio do id e retorná-lo usando o nosso DTO de detalhamento. Tudo isso sempre retornando ResponseEntity. 

============ERROS NA API============

Por padrão, o Spring devolve os erros com o stack trace completo do que deu erro no nosso código, juntamente com outras informações, como mensagem do erro, tudo isso em uma resposta com código 500. Isso acontece até nos casos de buscar um registro que não existe no nosso banco de dados por uma requisição de detalhamento.

Isso não é interessante, pois estamos expondo informações desnecessárias sobre o código da nossa API, mas podemos mudar o tratamento de erros do Spring e deixarmos de acordo com a nossa necessidade.

Podemos mudar o padrão com que o Spring lida com as respostas desses erros pelo arquivo application.properties, assim podendo fazê-lo não mandar o stack trace por padrão. Para isso usamos a propriedade:

"server.error.include-stacktrace=never"

Importante lembrar que só isso não é suficiente em todos os casos, pois devemos sempre nos preocupar em devolver o status code correto, sendo que o Spring sempre retornará 500, o que não é o ideal.

É impossível decorar todas as propriedades, por isso sempre podemos consultar a documentação nesse link: "https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html", sabendo qual é o tipo de property que queremos.

============TRATANDO ERRO 404============

Da forma que eu fiz, cada método tinha que implementar a lógica de retornar um erro 404 como resposta, mas o Spring tem uma solução pra tratar isso de forma global para todos os métodos que gerarem um tipo específico de Exception.

A solução é criar uma classe com a annotation @RestControllerAdvice, que fará com que o Spring saiba que aquela classe é uma classe que ele tem que carregar e que será utilizada pelos @RestController, e dentro dela colocar métodos com a annotation @ExceptionHandler(EntityNotFoundException.class) contendo a lógica de retorno da resposta no caso de acontecer uma Exception daquele tipo.

Importante lembrar que podemos receber por parâmetro a Exception que estamos tratando no método @ExceptionHandler, assim podendo extrair informações dela.

============TRATANDO ERRO 400============

Por padrão, o Spring envia uma série de informações em erros de bad request, que muitas vezes são desnecessariamente complexas e não tão úteis. Por isso é importante tratarmos as respostas 400, devolvendo apenas as informações corretas sobre o que está errado na requisição do cliente.

Para fazer o tratamento da resposta, criamos outro método @ExceptionHandler, só que dessa vez para tratar a Exception "MethodArgumentNotValidException".

Usamos o método getFieldErrors(); da própria Exception, que retorna uma List<FieldError> (FieldError é uma classe que tem vários getters que nos permitem tirar informações sobre o erro que deu no campo específico), que usamos para converter em um DTO com as informações que queremos passar para o cliente sobre o que está errado nos campos da requisição. Exemplo:

@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity tratar400(MethodArgumentNotValidException e) {
    List<FieldError> erros = e.getFieldErrors();
    List<CampoInvalidoDTO> camposInvalidos erros.stream().map(CampoInvalidoDTO::new).toList();

    return ResponseEntity.badRequest().body(camposInvalidos);
}

private record CampoInvalidoDTO(String campo, String mensagem) {
    public CampoInvalidoDTO(FieldError erro) {
        this(erro.getField(), erro.getDefaultMessage());
    }
}

Se mandarmos na requisição o Header "Accept-Language" com o valor "pt-br", as respostas virão em português. Isso funciona para algumas línguas, mas é um número limitado.

Podemos também mudar as mensagens de erro para cada campo específico quando a requisição não estiver de acordo com a validação.

Para isso, basta colocarmos o parâmetro "message = <mensagem>" nas próprias annotations de validação que colocamos nos DTOs. Também podemos colocar essas mensagens em um arquivo "ValidationMessages.properties" e lê-las usando a sintaxe:

message = "{<nome da propriedade>}".

Exemplo:

@NotBlank(message = "{nome.obrigatorio}")
String nome;
