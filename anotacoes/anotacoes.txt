Quando vamos inicializar um projeto Spring, não precisamos necessariamente usar o Spring Initializr, podemos criar um projeto Maven do zero e ir adicionando as dependências manualmente, e fazendo a estrutura necessária do projeto.

============spring-boot-starter-parent============

"parent", quando se trata do pom.xml, é um arquivo pom.xml pai que pode ser herdado. Para fazer essa herança, basta colocarmos as informações do pom.xml que queremos como pai no nosso pom.xml alvo envolta de uma tag 

  <parent>
    </>
  </parent>.

No entanto, quando se trata do spring-boot-starter-parent, devemos tratar ele como uma dependência.

============spring-boot-starter============

É a dependência mais básica do Spring Boot, que traz com ela o "core" do Spring Boot.

============spring-boot-maven-plugin============

É um plugin que colocamos na tag de build, e irá servir para fazer o build com todas as dependências corretamente.

============RODAR APLICAÇÃO SPRING BOOT============

A classe principal que vai rodar a nossa aplicação Spring, por convenção, sempre terá o nome do nosso artefato e terminará com Application.

Essa classe é a classe executável, ou seja, temos que ter um método main dentro dela.

Para o Spring saber que aquela é a classe principal da aplicação, devemos marcá-la com a annotation @SpringBootApplication.

No nosso método main devemos executar o método SpringApplication.run(<nome da classe main>.class, args);

============Spring x Spring Boot============

Spring é um framework dividido em módulos, com a ideia de que você só usará os módulos conforme a necessidade do projeto. Ele existe desde 2002, mas na época era preciso criar configurações extensas em XML ou uma classe Java para configurar cada módulo e cada coisa que voce ia utilizar. Foi para combater isso que o Spring Boot nasceu, tornando a tarefa de criar configurações automática e muito mais rápida e de fácil manutenção.

O Spring Boot não vem como uma dependência, mas sim na tag parent, que funciona como uma herança para outro pom.xml.

O Spring Boot inverteu o fluxo de rodar aplicações web Java, fazendo termo o servidor Tomcat na nossa aplicação, e não o contrário, por isso conseguimos rodar a aplicação apenas executando a nossa classe com o método main que chama o método run do SpringApplication.

============Spring Dev Tools============

Funciona como um live-server.

Para utilizarmos no IntelliJ, precisamos marcar a opção "build automatically" e a opção de "allow auto-run mesmo quando a aplicação estiver rodando" no compiler, pois apenas ter a dependência não é o suficiente.

============@RestController============

É a annotation que especifica que nossa classe é um controlador REST.

Precisa ter a annotation @RequestMapping, que passa o caminho inicial da requisição, como "/", por exemplo.

============@GetMapping============

Define que o método no RestController vai ser chamado por requisições GET.

Existem outras anotações no mesmo padrão para os demais métodos HTTP.

============REQUEST BODY============

O corpo da requisição no Spring nada mais é do que um parâmetro do método que vai ser chamado na requisição. Porém, para o Spring entender que aquele parâmetro deve receber o corpo da requisição, precisamos marcá-lo com a annotation @RequestBody.

============CORS Spring============

Para acessarmos nossa API de origens diferentes, precisamos criar uma classe de configuração que irá definir as origens permitidas e os métodos HTTP permitidos a partir dessas origens. A classe deverá ficar mais ou menos assim:

@Configuration
public class CorsConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "TRACE", "CONNECT");
    }
}

============DTO============

Data Transfer Objects são um padrão de objetos feitos para representar os dados de entrada e saída de requisições na nossa API. Sempre iremos utilizar esse padrão.

Nas versões mais recentes do Java, utilizamos Records para representar esses DTOs.

============RECORDS============

Record é um tipo de classe específico das versões mais recentes do Java, que são classes imutáveis de dados, onde não precisamos criar atributos nem métodos para termos as funções de get e etc.

============ADICIONANDO DEPENDÊNCIAS============

Podemos pegar as dependências diretamente do Spring Initializr indo na aba EXPLORE, que irá mostrar como o pom.xml será gerado, assim podendo copiar exatamente as dependências do jeito certo.

============ Spring Data JPA============

Spring Data JPA é o módulo do Spring que nos permite trabalhar com o JPA para a persistência dos dados, fazendo a conexão com o banco de dados e já usando o Hibernate como ORM.

Assim que adicionamos a dependência no nosso projeto, ele tentará fazer a conexão com o banco de dados, gerando uma falha se não conseguir. Para especificarmos os parâmetros de conexão, temos que mexer no nosso arquivo application.properties, que é onde colocaremos as properties usadas na nossa aplicação.

temos que passar as propriedades de forma específica, o que é meio difícil de decorar no começo, mas vou listar as de conexão com banco aqui:

- spring.datasource.url=<conexão> (usa driver jdbc)
- spring.datasource.username=<username>
- spring.datasource.password=<password>

Podemos usar YAML também, o que facilita o uso de informações externas, o que ajuda no caso de querermos ocultar a conexão ao banco, por exemplo.

Algumas annotations do JPA que podemos utilizar:

- @Table(name = <nome da tabela>): especifica a tabela que estará mapeada com a entidade.
- @Entity(name = <nome>): especifica que a classe é uma entidade JPA, que estará linkada com uma entidade do nosso banco de dados.
- @Id: especifica que é uma chave de uma entidade (PK, FK)
- @GeneratedValue(strategy = GenerationType.IDENTITY): é uma annotation que especifica que aquele valor será gerado automaticamente pelo JPA. Passando uma strategy que irá dizer o tipo de geração automáticaque irá ser utilizada. No caso de um @Id, será IDENTITY.
- @Enumerated(EnumType.STRING): especifica que o atributo será um enum, também passando o tipo do Enum (String, nesse caso).
- @Embedded: usamos quando temos outra entidade dentro da nossa entidade, mas não queremos fazer um relacionamento, e sim que os atributos da outra entidade apareçam na mesma entidade.
- @Embeddable: especifica que a classe vai ser usada com @Embedded.

É importante lembrar que, mesmo tendo a annotation @Table na nossa entidade, se a tabela não existir, o JPA não irá criá-la automaticamente, o que irá gerar uma Exception.

Normalmente fazemos o link com o banco de dados usando objetos DAO (Data Access Object), que vem da ideia de separarmos as regras de negócio das regras de acesso ao banco de dados, criando um objeto específico para isso e não deixando isso junto com controllers e etc., mas o Spring facilita isso e fazemos o uso de interfaces (repositories).

Exemplo de uso dos DAOs:

public class ProdutoDao {

    private final EntityManager entityManager;

    public ProdutoDao(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public void create(Produto produto) {
        entityManager.persist(produto);
    }

    public Produto read(Long id) {
        return entityManager.find(Produto.class, id);
    }

    public void update(Produto produto) {
        entityManger.merge(produto);
    }

    public void remove(Produto produto) {
        entityManger.remove(produto);
   }

}

Assim que faríamos a persistência no banco de dados usando apenas o JPA, e não o Spring Data JPA.

Um repositório é uma interface que podemos utilizar nas nossas regras de negócio e lógicas para fazer a persistência dos dados. Agora, inserir lógicas, tratamento de dados, ou acesso direto sem um controller ao nosso repositório é algo que nunca devemos fazer, pois assim como o DAO, os repositórios também servem para fazermos essa divisão, apesar de ficarem mais próximos das lógicas do que os DAOs.
Também é interessante saber que um repositório pode tratar de um ou mais DAOs, assim podendo utilizar o mesmo repositório para entidades que possuem entidades como atributo.

O padrão Repository incentiva um design orientado a domínio, o que torna mais fácil a compreensão do domínio e da estrutura de dados, além de, no Spring, tornar o nosso código mais fácil e mais legível, a partir do uso das interfaces.

============JpaRepository============

É a interface mãe das interfaces Repository que precisamos criar para ter a persistência dos dados no banco de dados. Sempre criaremos uma interface para cada entidade nossa, usando a convençaõ de passar o nome da entidade com "Repository" no final.

Essas interfaces precisam estender a interface JpaRepository, que irá receber um generics com dois tipos após o "extends", onde o primeiro parâmetro é a entidade e o segundo o tipo do atributo @Id dela.

Só de criar a interface e estender JpaRepository, já temos o nosso repository pronto para ser utilizado, apesar de podemos criar outros métodos e também sobrescrever os existentes.

Para utilizar esse repository, precisamos ter um atributo na nossa classe controller que irá ser uma instância dele. Como não somos nós que fazemos a inicialização desse objeto, precisamos falar pro próprio Spring fazer isso com a annotation @Autowired, que é a annotation responsável por fazer a injeção de dependências no Spring.
Tendo esse objeto como atributo, podemos usar os métodos disponíveis nele dentro dos nossos métodos responsáveis por tratar as requisições, como, por exemplo, o método save();, responsável por salvar os dados no banco de dados.

Para instanciarmos uma entidade a partir de um DTO, precisamos de um construtor que recebe o DTO e passa os campos dele para a entidade (ou podemos usar o @AllArgsConstructor e passar os dados do DTO para ele no controller, mas isso é um saco).

============LOMBOK============

É uma biblioteca feita para utilizarmos annotations que geram códigos verbosos para nós, como getters e setters, toString e etc.

Algumas annotations:

- @Getter: gera os getters.
- @NoArgsConstructor: gera o construtor default.
- @AllArgsConstructor: gera um construtor com todos os atributos.
- @EqualsAndHashCode(of = <campo(s) usado(s) para fazer o HashCode>): gera o equals(); e o hash();, por padrão usando todos atributos para isso.

============FLYWAY MIGRATIONS============

Ferramentas de Migrations são ferramentas que nos dão o controle do versionamento do nosso banco de dados utilizado na aplicação. O FLYWAY é a ferramenta do Migrations que o Spring dá suporte, e ela servirá para fazermos todas as mudanças na estrutura do banco de dados que precisarmos, como criação de tabelas, modificação, exclusão, etc.

O FLYWAY não é um módulo do Spring, mas o Spring tem integração com ele, deixando mais fácil de utilizá-lo.

As migrations no Spring sempre ficam no diretório:

"src/main/java/resources/db/migration"

São arquivos .sql com scripts feitos por nós do que vai ser feito na migration.
(normalmente temos que criar o diretório "db/migration")

Sempre que formos mexer em migrations, devemos parar a nossa aplicação.

**MIGRATIONS EXECUTADAS NÃO PODEM SER MODIFICADAS**

Se precisamos fazer uma alteração, devemos criar outro arquivo de migration com um versionamento acima do anterior.

Se acontecer algum erro com a migration, devemos ir no banco de dados e executar o seguinte script:

"delete from flyway_schema_history where success = 0;"

Pode ser que alguma tabela ou atributo sejam criados em uma execução de migration com falha. Nesse caso, podemos apenas deletar o banco de dados e criá-lo novamente, que assim todas as migrations serão executadas do zero.

============PADRÃO NOMENCLATURA .sql FLYWAY============

Nos arquivos .sql do FLYWAY sempre temos que seguir o padrão de nomenclatura:

"V<número versionamento>__<nome descritivo>.sql"

Os scripts sql são executados automaticamente.

Os scripts sql são scripts sql normais, mudando conforme o banco de dados que estamos utilizando.

============@Transactional============

Precisamos dessa annotation em métodos de controladores que irão executar uma transação direta de dados com o nosso banco de dados, seja ela um create, um read, um update ou um delete.

============BEAN VALIDATION============

Bean Validation é uma especificação de validação do Java e o Spring tem um módulo chamado "Validation" que facilita o uso dessa especificação.

Precisamos fazer validações em parâmetros recebidos por requisições à nossa API, ou seja, precisamos fazer essas validações no DTO que irá guardar os dados recebidos no corpo da requisição.

A validação no Spring é feita por meio de annotations, o que torna muito mais fácil e legível fazer essas validações.
Temos que passar a annotation @Valid no método do controller que está recebendo o corpo da requisição para as verificações serem feitas.

Algumas annotations:

- @NotNull: especifica que o atributo não pode ser null.
- @NotBlank: especifica que o atributo não pode estar vazio, mesmo que não seja null (também não deixa ser null).
- @Email: especifica que a String deve estar no formato correto de um email.
- @Pattern(regexp = <regex>): especifica um padrão que a String deve seguir utilizando regex.
- @Valid: especifica que um atributo também tem que ser validado, e é usado no caso de termos outro DTO dentro do nosso DTO. Lembrando que temos que ter as validações dos campos no outro DTO também.

============REQUISIÇÕES GET============

Para darmos respostas à requisições GET, usamos a annotation @GetMapping no nosso controller. Podemos ter outro objeto DTO para devolver como resposta à requisição, devolvendo apenas os dados realmente necessários do nosso objeto que está sendo acessado.

Para pegarmos os registros do nosso banco de dados, podemos usar os métodos de "find" do nosso repository, que irão retornar um ou mais registros da nossa entidade, tendo o tipo do objeto como a classe da entidade.
Como temos que retornar uma coleção de objetos DTO, apenas usar esses métodos e tentar retornar o retorno deles na nossa resposta não dá certo, pois o tipo dos objetos retornados ainda não foi convertido para a nossa classe DTO. Para fazermos isso, podemos usar stream() e map():

"return repository.findAll().stream().map(MedicoDTOListagem::new).toList();"

Nesse exemplo, o map mapeia cada objeto do fluxo de dados para outro tipo, MedicoDTOListagem, nesse caso, usando o próprio construtor do record DTO como método, que recebe um objeto do tipo Medico, e transforma em uma lista desse tipo a partir da lista que tínhamos. 

Podemos ter construtores em Records, mas é importante lembrar que esses construtores personalizados sempre têm que usar o construtor padrão dos records, que é o construtor que recebe todos os atributos que declaramos na declaração do Record. Chamamos esse construtor da seguinte forma:

"this(<parâmetros recebidos no record...>);"

Sempre é bom usar DTOs, tanto para dados que estão sendo recebidos na API quanto para dados que estão sendo retornados por ela.

============PAGINAÇÃO============

Paginação é dividir o retorno das requisições get em páginas, devolvendo apenas um certo número de objetos por página.

O Spring já possui uma funcionalidade que faz essa paginação para nós, não precisamos implementar na mão. Essa funcionalidade está na interface Pageable, e podemos receber um objeto com esse tipo por parâmetro no nosso método.

Quando recebemos esse objeto, podemos passar ele como parâmetro do método findAll(); do repository, o que fará com que o nosso retorno não possa ser mais uma List, e sim uma Page.
O método findAll();, quando usado com um Pageable, já tem um método map(); que funciona do mesmo jeito que o map(); de Stream, mas já retornando uma Page que contém os objetos retornados, sem a necessidade de usarmos um método toList();, ou algo do tipo.

@GetMapping
public Page<MedicoDTOListagem> listar(Pageable pageable) {
    return repository.findAll(pageable).map(MedicoDTOListagem::new);
}

Quando utilizamos a paginação do Spring e implementamos nosso código dessa forma, a resposta da requisição virá de forma diferente, tendo os registros dentro de um array "content" e as informações sobre a paginação em um objeto "pageable", o que é útil para o front saber fazer melhor a paginação.

Por padrão, uma Page sempre terá 20 registros nela, mas podemos mudar isso utilizando os parâmetros "size=<número de registros na página>" e "page=<número da página a ser exibida>" como query string na requisição à nossa API. O índice das páginas começa no 0, assim como em listas. O Spring lê essa query string automaticamente.

============ORDENAÇÃO============

Por padrão, os registros sempre virão na mesma ordem em que eles foram inseridos no banco de dados, mas nós podemos mudar essa ordem utilizando recursos do Spring.

Para mudar a ordem dos registros retornados na requisição, basta colocarmos o parâmetro "sort=<atributo utilizado na ordem>,<asc ou desc>" na query string, assim fazendo a ordenação a partir de um atributo da nossa entidade, podendo escolher se queremos na ordem crescente ou decrescente com os parâmetros "asc" ou "desc" após a vírgula (por padrão é asc).

Podemos juntar parâmetros de ordenação e paginação na nossa query string sem problema algum. Exemplo:

"http://localhost:8080/medicos?size=10&page=0&sort=nome,asc"

============@PageableDefault============

Por padrão, o Spring irá usar o size de 20 registros e nenhum sort, mas podemos mudar isso com essa annotaion, usando ela da seguinte forma:

@PageableDefault(size = <int tamanho>, sort = {"<atributos>"})

Sim, podemos ordenar por mais de um atributo, por isso precisamos passar um array com os nomes dos atributos usados na ordenação (em String).

Também podemos mudar a ordem padrão da direção (asc ou desc) usando o parâmetro "direction = Sort.Direction.<ASC ou DESC>".

Se passarmos uma query string especificando esses comportamentos, essa query string irá sobrescrever o padrão especificado por nós.

Podemos mudar o nome dos parâmetros recebidos na query string pelo nosso arquivo "application.properties". Exemplo:

spring.data.web.pageable.page-parameter=pagina
spring.data.web.pageable.size-parameter=tamanho
spring.data.web.sort.sort-parameter=ordem

Podemos mostrar o sql gerado pelo Hibernate no console especificando que queremos isso no "application.properties" também.

============REQUISIÇÕES PUT============

É sempre uma boa prática retornar o campo de id dos nossos objetos em requisições GET, pois o front-end utilizará esse campo para mandar requisições PUT, DELETE, etc.

Para modificarmos um registro no nosso banco de dados, temos que modificar a nossa entidade JPA, que pegamos por meio do id, utilizando o método findById(); do repository, por meio de um objeto DTO com os campos que queremos permitir a alteração. Normalmente iremos criar um DTO novo, pois se usarmos um que já tínhamos feito, todas as validações que colocamos serão realizadas, o que não é bom, pois a maioria dos campos não devem ser obrigatórios em uma modificação.

Para a modificação realmente ocorrer, precisamos ter um método na nossa entidade que recebe o DTO de atualização e atualiza os campos com base nos campos passados, fazendo as validações nesse método mesmo. No método que irá responder à requisição PUT, devemos chamar esse método de atualização, sem nem chamar nenhum método do repository, pois só de ter as annotations @PutMapping e @Transactional, o Spring irá entender que se trata de uma atualização e irá atualizar os dados no banco de dados também.

============EXCLUSÃO LÓGICA============

Exclusão lógica é sinalizar no nosso banco de dados e no sistema que um usuário está inativo ao excluí-lo, em vez de realmente excluir o registro dele.

============REQUISIÇÕES DELETE============

Nas requisições DELETE, também utilizaremos o id da nossa entidade a ser deletada, mas não precisamos passar um corpo na requisição para isso, basta usarmos um parâmetro dinâmico na URL, que definimos na própria annotation @DeleteMapping dessa forma: @DeleteMapping("/{parametro}"). Para usarmos esse parâmetro recebido dentro do nosso método que responde às requisições DELETE, temos que receber um parâmetro no método com o mesmo nome que demos ao parâmetro na annotation e passar a annotation @PathVariable nele.

O código irá ficar mais ou menos assim:

@DeleteMapping("/{id}")
@Transactional
public void excluir(@PathVariable Long id) {
    repository.deleteById(id);
}

Dessa forma excluímos mesmo o registro do banco de dados, o que não é uma exclusão lógica.

============EXCLUSÃO LÓGICA COM DELETE============

Funciona basicamente da mesma forma que um PUT, pois só iremos mudar o campo de status para false (0 no banco de dados).

============FILTRAR LISTAGEM============

Se seguirmos o padrão de nomenclatura dos métodos do repository, basta criarmos um método novo na interface e ele já estará disponível para uso com uma lógica pronta checando o valor de algum atributo. Esse padrão é:

"findBy<Atributo><Valor>();" ("findByStatusTrue();", por exemplo)

============RETORNANDO STATUS CODE CORRETO============

Quando um método nosso retorna void, por padrão, o retorno que o Spring dará será um status 200 (ok) e nenhum corpo na resposta. Podemos mudar isso utilizando os métodos estáticos da classe ResponseEntity, que têm nomes descritivos com o tipo do status retornado. Por exemplo:

"return ResponseEntity.ok().build();"

Dessa forma, retornariamos um status 200 (ok).

Podemos definir que o retorno da ResponseEntity terá um corpo. Para isso, usamos Generics, colocando dentro dos sinais de menor e maior o objeto que vai ser o corpo da resposta. Por exemplo:

"ResponseEntity<Page<MedicoDTOListagem>>"

Para realmente retornar essa ResponseEntity contendo um corpo, basta passarmos como parâmetro no método estático que gera a ResponseEntity o objeto que queremos como corpo. Por exemplo:

"return ResponseEntity.ok(<objeto>).build();"

============201 CREATED============

O status code 201 (created) é o status code que deve ser retornado em requisições POST, que cadastraramalgum item no nosso sistema a partir da requisição. Além de retornar o status code 201, temos que retornar o novo registro com as informações cadastradas no corpo da resposta e um header chamado "Location", que irá especificar ao front-end onde aquele recurso está disponível na nossa API.

Para retornarmos um "ResponseEntity created" no Spring, precisamos usar o método:

"ResponseEntity.created(<URI>).body(<objeto>);"

Essa URI recebida como parâmetro no método created(); é a URI que vai ser utilizada no header "Location", e para gerá-la utilizamos a classe UriComponentsBuilder, que recebemos por parâmetro no nosso método. Código de exemplo para gerar a URI a partir da classe UriComponentsBuilder:

"uriBuilder.path("/medicos/{id}").buildAndExpand(medico.getId()).toUri();"

O que esse código faz é montar a URI com o caminho padrão da nossa API, sem termos que especificá-lo no código. Por exemplo, "http://localhost:8080/".

Importante lembrar que devemos gerar a URI após ter salvo o registro no banco de dados, pois se fazemos isso antes, a entidade que pegamos o id ainda não possui o id, já que esse é um valor gerado pela JPA quando salvamos a entidade no banco de dados.

No método body();, passamos um DTO de nossa escolha.

============DETALHAMENTO============

Já temos um CRUD completo na nossa API, mas normalmente isso não é o suficiente. Na maioria dos casos, também precisamos de algum método que detalhe um registro buscando-o por id.

Para fazer isso é bem simples, basta acessarmos o registro desejado por meio do id e retorná-lo usando o nosso DTO de detalhamento. Tudo isso sempre retornando ResponseEntity. 

============ERROS NA API============

Por padrão, o Spring devolve os erros com o stack trace completo do que deu erro no nosso código, juntamente com outras informações, como mensagem do erro, tudo isso em uma resposta com código 500. Isso acontece até nos casos de buscar um registro que não existe no nosso banco de dados por uma requisição de detalhamento.

Isso não é interessante, pois estamos expondo informações desnecessárias sobre o código da nossa API, mas podemos mudar o tratamento de erros do Spring e deixarmos de acordo com a nossa necessidade.

Podemos mudar o padrão com que o Spring lida com as respostas desses erros pelo arquivo application.properties, assim podendo fazê-lo não mandar o stack trace por padrão. Para isso usamos a propriedade:

"server.error.include-stacktrace=never"

Importante lembrar que só isso não é suficiente em todos os casos, pois devemos sempre nos preocupar em devolver o status code correto, sendo que o Spring sempre retornará 500, o que não é o ideal.

É impossível decorar todas as propriedades, por isso sempre podemos consultar a documentação nesse link: "https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html", sabendo qual é o tipo de property que queremos.

============TRATANDO ERRO 404============

Da forma que eu fiz, cada método tinha que implementar a lógica de retornar um erro 404 como resposta, mas o Spring tem uma solução pra tratar isso de forma global para todos os métodos que gerarem um tipo específico de Exception.

A solução é criar uma classe com a annotation @RestControllerAdvice, que fará com que o Spring saiba que aquela classe é uma classe que ele tem que carregar e que será utilizada pelos @RestController, e dentro dela colocar métodos com a annotation @ExceptionHandler(EntityNotFoundException.class) contendo a lógica de retorno da resposta no caso de acontecer uma Exception daquele tipo.

Importante lembrar que podemos receber por parâmetro a Exception que estamos tratando no método @ExceptionHandler, assim podendo extrair informações dela.

============TRATANDO ERRO 400============

Por padrão, o Spring envia uma série de informações em erros de bad request, que muitas vezes são desnecessariamente complexas e não tão úteis. Por isso é importante tratarmos as respostas 400, devolvendo apenas as informações corretas sobre o que está errado na requisição do cliente.

Para fazer o tratamento da resposta, criamos outro método @ExceptionHandler, só que dessa vez para tratar a Exception "MethodArgumentNotValidException".

Usamos o método getFieldErrors(); da própria Exception, que retorna uma List<FieldError> (FieldError é uma classe que tem vários getters que nos permitem tirar informações sobre o erro que deu no campo específico), que usamos para converter em um DTO com as informações que queremos passar para o cliente sobre o que está errado nos campos da requisição. Exemplo:

@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity tratar400(MethodArgumentNotValidException e) {
    List<FieldError> erros = e.getFieldErrors();
    List<CampoInvalidoDTO> camposInvalidos erros.stream().map(CampoInvalidoDTO::new).toList();

    return ResponseEntity.badRequest().body(camposInvalidos);
}

private record CampoInvalidoDTO(String campo, String mensagem) {
    public CampoInvalidoDTO(FieldError erro) {
        this(erro.getField(), erro.getDefaultMessage());
    }
}

Se mandarmos na requisição o Header "Accept-Language" com o valor "pt-br", as respostas virão em português. Isso funciona para algumas línguas, mas é um número limitado.

Podemos também mudar as mensagens de erro para cada campo específico quando a requisição não estiver de acordo com a validação.

Para isso, basta colocarmos o parâmetro "message = <mensagem>" nas próprias annotations de validação que colocamos nos DTOs. Também podemos colocar essas mensagens em um arquivo "ValidationMessages.properties" e lê-las usando a sintaxe:

message = "{<nome da propriedade>}".

Exemplo:

@NotBlank(message = "{nome.obrigatorio}")
String nome;

============Spring Security============

É o módulo do Spring feito para trabalharmos com autenticação e autorização, tanto em aplicações web tradicionais, quanto em APIs.

Normalmente em aplicações web tradicionais, temos o modelo Steteful, o que significa que quando um usuário loga na aplicação, ele tem uma sessão que pertence a ele onde são guardadas várias informações específicas dele no servidor, para quando ele voltar continuar de onde ele parou. Quando se trata de uma API REST, ela deve ser Stateless, ou seja, não deve ter estado nenhum. O usuário deve fazer a requisição, se autenticar, se tiver acesso, a requisição fará o que tem que ser feito, e acabou.

O Spring Security é bem flexível e nos deixa  trabalhar desses dois modos, assim como usar diversos métodos nesses modos.

Principais objetivos do Spring Security:

- Autenticação
- Autorização
- Proteção contra ataques (CSRF, clickjacking, etc.)

Existem vários modos de lidarmos com autenticação em APIs, mas a mais comum é utilizando tokens. No curso, utilizaremos o JWT (JSON Web Token).

Fluxo de autenticação com JWT no Spring:

- Usuário envia informações de login como requisição para a API;
- A API checa no banco de dados se existe um usuário com as informações de login passadas, e se a senha bate;
- Se o usuário realmente existir e estiver tudo de acordo, a API gera e devolve um token JWT, para o client.

Esse token JWT tem que ser guardado pela aplicação client-side, pois ele será o que fará com que o login continue valendo.

Com o token já gerado, o client dispara a requisição com um Header chamado "Authorization", com o valor de Bearer TOKEN_JWT, que irá incluir o token na requisição. Se o token estiver certo e ainda for válido, o Spring processará a requisição normalmente, se não, ele irá bloquear a requisição.

Um problema que podemos ter com o uso do JWT é a expiração do token, que normalmente expira por volta de 10 minutos, o que normalmente faria com que o client tivesse que enviar outra requisição de login quando a expiração ocorresse. Isso não é nada prático e não é uma boa ideia.

Para combater isso existe o "refresh token", que é um token que demora mais para expirar e é gerado um novo a cada requisição feita com autenticação JWT. Ou seja, enquanto o usuário estiver mandando requisições pelo client com token JWT, a API retornará um novo token para cada requisição, que será o token utilizado na próxima requisição feita pelo usuário, assim fazendo com que a expiração demore mais e o usuário só precise fazer a autenticação após um período maior de tempo sem ter feito requisições para a API.

Por padrão, quando adicionamos o Spring Security no nosso projeto, ao iniciar a API ele irá gerar uma senha aleatória para login com o usuário "user" e bloquear qualquer requisição que não esteja logada com essas credenciais. Se tentamos disparar uma requisição pelo navegador sem estarmos logados, somos redirecionados para uma página de login poadrão do Spring Security. Usamos isso apenas para desenvolvimento, pois em produção não faz sentido usar o padrão do Spring Security. Além de que esse modelo funcionaria apenas em aplicações web Stateful, o que não é o caso de uma API REST, onde uma tela de login é responsabilidade exclusiva do front-end.

============APLICANDO AUTENTICAÇÃO============

Para fazermos a autenticação e autorização do jeito que precisamos na nossa API, precisaremos ter uma nova entidade chamada "Usuario", assim como uma nova tabela no banco que irá armazenar esses usuários.

Quando armazenamos senhas dos usuários, não podemos armazenar a senha em si, pois o texto exato da senha ficaria armazenado no banco de dados e alguém mal intencionade poderia facilmente aces´-la e usá-la. Para combater isso, usamos algoritmos de "hashing", que geram Strings muito maiores e de difícil dedução, assim só concedendo o acesso quando o usuário digitar a senha que será convertida exatamente para o hash guardado no banco de dados.

Existem muitos algoritmos de hashing populares e muitos que não são mais considerados seguros, mas o que utilizaremos será o Bcrypt, muito popular hoje em dia.

Para todas as ações que iremos fazer na tabela dos usuários no banco de dados, utilizaremos o repository normalmente. Porém, como estamos trabalhando com o Spring Security, temos que criar uma classe com a annotation @Service e que implementa a interface "UserDetailsService", para assim o Spring Security já ler essa classe automaticamente, sem termos que injetá-la em nenhum lugar, e usá-la para fazer a autenticação corretamente.

Essa classe @Service terá que ter um método:

"loadUserByUsername(String username) throws UsernameNotFoundException"

que é o método por onde acessaremos o repository dos usuários e retornaremos o usuário procurando ele por login (username).

Importante lembrar que podemos usar o padrão de nomenclatura dos repositories para já termos um método que busca automaticamente o usuário pelo atributo de login, sem termos que criar uma lógica na mão para isso. 
Por exemplo:

"UserDetails findByLogin(String login);"

UserDetails é uma classe do Spring Security que representa os detalhes do usuário.

Precisamos especificar ao Spring Security que queremos que ele trabalhe de forma Stateless, pois o padrão dele é Stateful. Não faremos isso por meio do application.properties, e sim por uma classe de configuração, pois isso não é uma configuraçãozinha básica, iremos mudar bastante coisa.

Para o Spring saber que essa é uma classe de configuração, passamos a annotation @Configuration nela juntamente com a annotation @EnableWebSecurity, que especificará que, além de ser uma classe de configuração, é uma classe de configuração de como o Spring Security irá se comportar.

Essa classe deve ter um método que retorna um objeto do tipo "SecurityFilterChain", que é a interface do Spring Security usada para configurar os processos de autenticação e autorização no Spring Security. Para retornar esse objeto, utilizaremos outro objeto recebido por parâmetro, que dessa vez será do tipo "HttpSecurity", que tem alguns métodos para buildarmos o SecurityFilterChain.

Como o JWT já é uma proteção contra ataques CSRF, precisamos desativar a proteção do Spring Security contra esses ataques que já vem por padrão. Para isso usamos os métodos do HttpSecurity:

".csrf().disable()"

Como queremos que o Spring Security trabalhe de forma Stateles, precisamos passar os métodos:

".sessionManagement().sessionCreationPolicy(
    SessionCreationPolicy.STATELESS
)"

Para o Spring conseguir usar esse objeto retornado pelo nosso método, temos que anotar o nosso método com a annotation @Bean, que é a annotation que especificar que aquele retorno é um Bean que pode ser utilizado tanto automaticamente pelo Spring, quanto injetado por nós em alguma classe.

Fazendo tudo isso, desabilitamos o padrão do Spring Security e agora ele não checa mais se o usuário está autenticado e autorizado.

============CONTROLLER DE AUTENTICAÇÃO============

Para o fluxo de autenticação ser realmente aplicado e conseguirmos autenticar por meio de uma requisição, precisamos ter um controller que vai ser o responsável por tratar essa requisição e fazer a autenticação do usuário.

Nesse controller, precisaremos chamar o nosso service responsável por fazer a autenticação, mas não podemos fazer isso diretamente. Quem chamará esse service será outra classe que injetamos no nosso controller, a classe AuthenticationManager.

Nesse objeto AuthenticationManager, usaremos o método "authenticate(<token>);", que retornará um objeto do tipo Authentication, que precisamos guardar em uma referência.

Ainda não temos esse token que o método espera como parâmetro, ou seja, precisamos gerá-lo. Para isso utilizaremos um objeto:

"new UsernamePasswordAuthenticationToken(<login>, <senha>);"

que será o nosso token gerado a partir dos atributos passados na requisição, recebidos no Spring como um DTO.

Com o token gerado, passamos ele para o método authenticate();

Tem um detalhe importante, por padrão o Spring não saberá injetar automaticamente o objeto AuthenticationManager, o que gera um erro ao iniciar a aplicação. Para o Spring injetar automaticamente esse objeto com a annotation @Autowired, temos que mudar as configurações do Spring. Como isso é uma configuração de segurança que precisamos modificar, faremos isso na classe de configuração de segurança que já criamos no projeto.

Na classe de configurações de segurança precisamos de outro método, agora um que irá retornar um @Bean do tipo AuthenticationManager. Para gerarmos esse @Bean e retornarmos ele com o nosso método, precisamos receber um objeto do tipo AuthenticationConfiguration como parâmetro no nosso método. Tendo o objeto, basta retornarmos o retorno do método getAuthenticationManager(); que teremos como injetar o AuthenticationManager no nosso controller por meio do @Autowired.

Além disso, temos que especificar para o Spring o tipo de algoritmo de hashing que estamos utilizando, que é BCrypt, no caso, pois, por padrão, ele não irá saber qual algoritmo usar quando chamamos os métodos de gerar token e autenticar. Criaremos um método na nossa classe de configuração de segurança que irá retornar um @Bean do tipo "PasswordEncoder" e irá retornar um "new BCryptPasswordEncoder();.

Ainda temos que implementar a interface UserDetails na nossa entidade Usuario, pois só assim o Spring saberá quais atributos da entidade são o login e senha. Essa interface nos fará implementar vários métodos que irão retornar informações que especificam uma série de coisas sobre o usuário. O que interessa para nós são os métodos getter "getUsername();" e "getPassword();".

Um método importante também é o "getAuthorities();", que precisa retornar uma "Collection<? extends GrantedAuthority>", que é uma coleção contendo as permissões do usuário representado na entidade. Como no projeto só temos uma única permissão geral, iremos apenas colocar como padrão:

"return List.of(new SimpleGrantedAuthority("ROLE_USER"));"

O padrão de nomenclatura dos acessos é começar com "ROLE_" e terminar com o nome da role em letra maiúscula.

============GERANDO TOKEN JWT============

Para gerar o token JWT e devolvê-lo na resposta, precisamos usar alguma biblioteca que gera o token de forma correta. No caso, iremos utilizar uma biblioteca que não é um módulo do Spring, e sim uma biblioteca avulsa que serve para gerar os tokens. (Importante lembrar que mesmo não sendo um módulo do Spring, nada nos impede de fazermos a nossa classe geradora de tokens se tornar um @Service que podemos usar na injeção de dependências no nosso controller.)

Entrando no jwt.io, temos uma lista com várias bibliotecas que geram tokens JWT. No curso iremos usar a Auth0.

Para gerarmos o token, precisamos criar uma instância da classe Algorithm, que representará o algoritmo utilizado para gerar o token. No curso utilizaremos o HMAC256, que é um algoritmo mais simples que funciona a partir de uma senha que passamos por parâmetro no método:

"Algorihtm algorithm = Algorithm.HMAC256(<senha>);"

Dessa forma temos o algoritmo que vai ser utillizado na hora de gerar o token, mas ainda não temos o token. Para realmente gerar o token, precisamos usar o método "JWT.create();", que pode ser continuado com vários métodos que nos fazem poder especificar quem gerou o token, normalmente passando o nome da nossa API, e o algoritmo usado para assinalar o token, por exemplo.

Alguns métodos de exemplo:

- withIssuer(<String>): especifica quem gerou o token.
- withSubject(<identificador do usuário>): especifica qual usuário é dono do token gerado.
- withClaim(<chave>, <valor>): serve para colocar informações no nosso token por meio de chave-valor.
- withExpiresAt(<Date || Instant>): especifica até quando o token vai ser válido.
- sign(<Algorithm>): especifica o algoritmo a ser utilizado para assinalar o token.

Importante lembrar que a referência Authentication que temos no controller de autenticação possui um método "getPrincipal();", que retorna um Object que é o usuário que chamou a autenticação, podemos fazer um type casting com ele para transformá-lo em usuário e usá-lo para ser o dono do token.

Código exemplo:

    public String gerarToken(Usuario usuario) {
        try {
            Algorithm algorithm = Algorithm.HMAC256("abc@1234");
            return JWT.create()
                    .withIssuer("Voll.med API")
                    .withSubject(usuario.getLogin())
                    .withExpiresAt(getExpiracao())
                    .sign(algorithm);
        } catch (JWTCreationException e) {
            throw new RuntimeException("Falha ao gerar o token JWT");
        }
    }

    private Instant getExpiracao() {
        return LocalDateTime.now().plusMinutes(10).toInstant(ZoneOffset.of("-03:00"));
    }

No nosso controller devemos criar um DTO com apenas um campo, que será  o do token. Temos que fazer isso para seguir o padrão de retornar um JSON nas nossas respostas, assim seguindo o padrão que estabelecemos e as boas práticas.

também devemos ocultar a senha utilizada no HMAC256. Para isso podemos criar uma propriedade nossa (sem seguir as padrões do Spring) no arquivo application.properties, utilizando uma variável de ambiente para ler a senha pelo arquivo. Exemplo:

"jwt.token.password=${JWT_PASSWORD:<padrão>}"

Se o Spring não encontrar essa variável de ambiente no nosso computador, ele irá usar o que passarmos depois do ":" como padrão. Assim não precisamos nos preocupar em criar essa variável de ambiente na nossa máquina local.

É essa sintaxe que usamos para ler variáveis de ambiente no application.properties.

Para lermos propriedades nossas que colocamos no application.properties precisamos utilizar a annotation @Value("${<nome da propriedade>}") no atributo que queremos atribuir o valor da propriedade.

Com todos esses passos seguidos, temos a nossa autenticação já gerando o token e tudo mais, mas ainda não estamos fazendo nenhuma autorização, ou seja, mesmo sem fazer a autenticação ainda conseguimos disparar qualquer requisição que quisermos.

============AUTORIZAÇÃO============

Para aplicarmos a autorização, precisamos verificar se a requisição tem um token válido antes mesmo de ela chegar no controller, pois se fôssemos tratar isso no controller, isso ia gerar muita repetição de código.

Para isso, precisamos de um interceptador, alguma coisa que vai receber a requisição antes de passá-la para o controller. Um filter faz exatamente isso e é o que iremos usar.

Filters não são exclusividade do Spring, se estivéssemos desenvolvendo um projeto Java EE, muito provavelmente também usariamos algo assim.

============DispatcherServlet============

É a classe do Spring MVC que controla todas as requisições e manda elas para os controllers posteriormente.

============HandlerInterceptor============

É a classe do Spring MVC responsável por interceptar as requisições mandadas do DispatcherServlet para o controller. As requisições sempre passam pelo HandlerInterceptor.

============Filter || HandlerInterceptor============

A diferença entre esses dois é que o Filter é uma especificação dos próprios Servlets, enquanto o HandlerInterceptor é uma classe do Spring mesmo.

Enquanto um Filter irá filtrar a requisição antes mesmo de o Spring ler ela, o HandlerInterceptor irá lê-la somente após ela ter passado pelo DispatcherServlet, o que faz com que a gente consiga ter várias informações que o Spring passa para a gente, como o controller responsável por responder àquela requisição e etc.

Podemos usar tanto um quanto o outro para fazer a autenticação, os dois vão cumprir o mesmo papel nesse caso.

Filter sempre chama o próximo Filter até não tiver mais Filters e a requisição chegar no controller.

============APLICANDO FILTER============

Apesar de que iremos usar Filter no curso, iremos usar um filter específico do Spring, que nos dá muitas facilidades para implementá-lo. Em vez de implementar a interface Filter, iremos estender a classe OncePerRequestFilter, que é uma classe Filter do Spring que implementa a interface Filter e é executado apenas uma vez por request. Precisamos sobrescrever o método "doFilterInternal(<args>);", que é o método que irá aplicar realmente o filtro.

Como queremos que o Spring carregue a nossa classe Filter automaticamente, precisamos marcar ela com a annotation @Component, que diz para o Spring que aquela classe é um componente genérico que precisa ser carregado por ele.

============doFilterInternal(<args>);============

É o método que irá aplicar o nosso filtro. Parâmetros que ele recebe:

- HttpServletRequest request: a requisição que está sendo filtrada.
- HttpServletResponse response: a resposta do Servlet à nossa requisição.
- FilterChain filterChain: a cadeia de filtros existentes. Se existirem mais filtros, ele passa para o próximo, se não, vai para o controller. Para isso acontecer, precisamos chamar o método "doFilter();" do FilterChain passando o request e o response como parâmetro.

Apenas seguindo estes passos o nosso filtro já está funcionando, mas ainda temos que fazer a lógica de checar o token e passar ou não na autorização.

============RECUPERANDO O TOKEN============

Precisamos validar o token, ou seja, ver se ele realmente foi gerado pela nossa API e etc.

O token não deve ir no corpo da requisição, e sim no Header "Authorization", que é o Header específico para mandarmos a informação de autorização, no nosso caso o JWT. Normalmente colocamos o nosso token após o prefixo "Bearer", por questões de boa prática e para evitar erros.

Para pegarmos esse Header no nosso Filter, basta utilizarmos o método "getHeader(<nome do Header>);" do nosso HttpServletRequest. Se ele não tiver sido enviado, vai ficar como nulo. Nesse caso podemos jogar uma RuntimeException com uma mensagem personalizada e devolver um DTO com essa mensagem a partir de um método @ExceptionHandler.

Assim já temos o token enviado no Header da requisição, mas ainda não temos a lógica de validar esse token.

============VALIDANDO TOKEN============

Faremos a validação na própria classe @Service responsável por gerar o nosso JWT.

Na própria documentação da biblioteca utilizada temos um exemplo de como fazer isso, e é muito parecido com a forma que geramos o JWT.

Utilizamos o método "JWT.require(<Algorithm>)" seguido de métodos que irão "buildar" a nossa verificação. Após esses métodos, utilizamos o método "verify(<token>)" com o token que veio na requisição. Se o token for válido, podemos cahamr outros métodos, como o "getSubject();", que irá retornar o usuário dono daquela chave.

Precisamos de um Algorithm com a mesma senha do que utilizamos para gerar o JWT.

Tudo isso deve estar dentro de um try/catch, pois se a verificação falhar será gerada uma JWTVerificationException.

Dessa forma nós já estamos validando se o usuário tem a autorização de fazer aquela requisição, mas ainda não especificamos isso para o Spring, ou seja, por mais que o token seja enviado e a requisião passe, o usuário não está sendo autenticado novamente, pois a nossa API é Stateless. Temos que especificar essa autenticação para o Spring.

============AUTENTICANDO USUÁRIO============

Para fazer essa autenticação, precisaremos mudar a nossa classe @Configuration que cuida de como o Spring Security se comporta.

Utilizaremos o método "authorizeHttpRequests()" para dizer que as requisições precisam de uma autorização e autenticação juntamente com o método "requestMatchers(HttpMethod.<método>, <path pattern>).permitAll()" para dizer ao Spring para ignorar a autenticação/autorização em caminhos específicos com métodos HTTP específicos nas requisições. Podemos também utilizar os métodos "anyRequest().authenticated()" para dizermos que qualquer outra requisição além da que marcamos para permitir sem autorização necessite ser validada a autorização.

Importante lembrar que temos vários métodos que podemos encadear, como o "hasRole(<String role>)", que só vai autorizar aquela requisição para um usuário que tiver a role especificada no parâmetro. Também podemos fazer isso usando o MethodSecurity, por meio da annotation @Secured("<Role>") nos próprios métodos que queremos que só quem tenha uma role específica possa acessar. Bom lembrar que para habilitar o MethodSecurity, precisamos especificar isso na nossa SecurityConfiguration com a annotation @EnableMethodSecurity(securedEnabled = true).

Assim especificamos ao Spring que o usuário tem que estar autorizado para fazer várias requisições, mas mesmo mandando o token e estando autorizado isso não irá funcionar, pois ainda não falamos para o Spring que ele deve fazer essa autorização nas requisições.

Para fazer isso, no nosso Filter precisamos usar a classe SecurityContextHolder, que é uma classe do Spring que nos dá possibilidade de forçarmos algumas coisas do nosso contexto de segurança, como forçar que o usuário está autenticado. Exemplo de uso:

"SecurityContextHolder.getContext().setAuthentication(<Authentication>);"

Como visto no exemplo acima, temos que passar um objeto Authentication como parâmetro para o último método. Podemos criar um objeto desse tipo utilizando o construtor da classe UsernamePasswordAuthenticationToken, que recebe 3 parâmetros:

- principal: o objeto a ser autenticado, no nosso caso o usuário.
- credentials: as credenciais. Se estivemos passando o objeto em si a ser autenticado, podemos passar esse parâmetro como null.
- authorities: aquela lista de autoridades do usuário.

Assim temos o nosso objeto Authentication que podemos passar para o método "setAuthentication();", agora forçando o Spring a fazer a autenticação se estiver tudo correto.

Só que mesmo fazendo isso ainda não funciona, ele continua dando 403 para tudo. Isso acontece pois o filtro do próprio Spring é chamado antes do nosso, ou seja, o Filter do Spring vê que não estamos logados e devolve 403 direto, nem chega no nosso Filter. Para mudar isso precisamos mudar a ordem dos filtros.

Para mudar a ordem dos filtros, basta colocarmos mais um método no nosso método que retorna o SecurityFilterChain, que é o:

"addFilterBefore(<Filter atrás>, <Filter na frente>)"

Precisamos passar como primeiro parâmetro o nosso filtro (precisamos de uma instância dele, por isso devemos usar a injeção de dependências) e como segundo parâmetro o filtro que o Spring usa automaticamente, que é o UsernamePasswordAuthenticationFilter, assim fazendo com que o nosso filtro seja executado antes dele.

============DATAS NA REQUISIÇÃO============

Quando vamos receber datas na requisição, que irá ser colocada em um campo do tipo LocalDateTime no nosso DTO, precisamos receber uma String que representa uma data no formato correto que o Spring entende.

Esse formato é:

"<AAAA-MM-DD>T<HH:mm:SS>"

Por exemplo:

"2023-02-27T10:00"

Perceba que os segundos são opcionais, assim como o tempo que vem após o "T".

Importante saber que podemos validar no nosso DTO se a data recebida na requisição é uma data no futuro, o que é muito útil.

Para isso, basta colocarmos a annotation @Future do Spring Validation no nosso campo que estará a data.

Podemos alterar o padrão de Strings de datas do Spring, assim podendo utilizar outro padrão de nossa escolha nas requisições.

Para isso utilizamos:

"@JsonFormat(pattern = <novo padrão>)"

Por exemplo:

@JsonFormat(pattern = "dd/MM/yyyy HH:mm")

Bem intuitivo.

============RELACIONAMENTOS EM ENTITIES============

O Spring Data JPA e o JPA em si nos fornecem diversas annotations para trabalharmos com nossas entidades. Entre elas temos as annotations que nos permitem trabalhar com relacionamentos entre as nossas entidades.

Não irei entrar em detalhes sobre cada uma delas, mas é importante lembrar que:

- Todas elas vêm por padrão com o FetchType.LAZY, exceto as @ManyToOne e @OneToOne;
- A primeira palavra de todas elas sempre se refere à entidade na qual estamos estabelecendo o relacionamento, isto é, se utilizamos a annotation @ManyToOne, estamos dizendo ao Spring que uma instância da nossa entidade terá apenas uma instância da entidade em questão, já essa instância da outra entidade poderá ter várias instâncias da nossa entidade com relacionamento com ela.

Importante saber que o FetchType especifica se os relacionamentos serão carregados mesmo sem o uso deles ou não, onde com o FetchType.LAZY não serão e com o FetchType.EAGER serão.

============@JsonAlias({<aliases...>})============

É uma annotation que nos permite definir nomes alternativos para campos do nosso DTO que irá receber dados do corpo da requisição, assim fazendo com que mesmo que a aplicaçõa cliente envie os dados com atributos com nomes diferentes, mapeamos os nomes usados para os atributos corretos do nosso DTO.

Por poder receber um array como parâmetro, podemos ter vários aliases para um só atributo do DTO, o que é muito bom.

============RESPONSABILIDADE CONTROLLER============

Os controllers devem apenas controlar o fluxo de execução, isto é, não devem ter regras de negócio, lógicas, cálculas dentro deles, apenas fazer o fluxo do que chamar e que resposta retornar dependendo do que acontecer.

Para aplicarmos regras de negócio e etc, temos que utilizar uma classe @Service.

============ALL ARGS CONSTRUCTOR============

Até agora não havia utilizado o @AllArgsConstructor de nenhuma entidade, então não sabia muito bem a utilidade dele, mas agora descobri.

O @AllArgsConstructor é muito útil quando precisamos passar diversos objetos, que podem ser entidades JPA também, para construir o nosso objeto, uma vez que para termos os objetos que serão passados nesse construtor, temos que ter alguma lógica de busca das entidades nos seus respectivos repositories, pois não podemos receber um objeto instanciado no corpo de uma requisição, e fazer essa lógica de inicialização do objeto diretamente dentro da entidade em que criaríamos o construtor seria uma má prática.

============VALIDAÇÕES DE INTEGRIDADE============

As vezes precisamos checar se algum valor recebido no corpo da requisição é íntegro, ou seja, mesmo que esteja válido no padrão que colocamos no Spring Validation, precisamos checar se aquele valor realmente existe no nosso banco de dados, por exemplo.

Se recebemos um id de um paciente e precisamos pegar esse paciente no repository, primeiro precisamos checar se existe um paciente com aquele id.

Para isso temos alguns métodos de verificação nos repositories, um deles sendo o "existsById(Long id);", que checa se existe um registro no banco de dados com o id passado por parâmetro.

============QUERIES PERSONALIZADAS NO BANCO============

As vezes podemos precisar de queries personalizadas no nosso banco para buscar entidades com filtros mais complexos dos que conseguimos fazer apenas utilizando o padrão de nomenclatura dos repositories.

Para isso utilizamos a annotation @Query(<JPQL query>) em cima do método que criamos.

Essa annotation nos permite fazer queries personalizadas utilizando a JPQL (Java Persistence Query Language), uma linguagem de query aos bancos de dados que nos permite escrever em uma sintaxe onde podemos utilizar valores dinâmicos para atributos e respeitando os nomes dos atributos da entidade JPA em si, mesmo que sejam diferentes no banco de dados.

Uma query de exemplo:

@Query("""
                select m from Medico m
                where
                m.ativo = 1
                and
                m.especialidade = :especialidade
                and
                m.id not in(
                        select c.medico.id from Consulta c
                        where
                        c.data = :data
                )
                order by rand()
                limit 1
                """)

Podemos perceber que criamos uma referência com o nome "m" para o médico, onde para acessar os atributos apenas utilizamos um "." com o nome do atributo que queremos em seguida.
Também podemos perceber que temos alguns atributos com o sinal ":" antes do nome quando estamos fazendo comparações. Esses atributos recebem este sinal porque são atributos dinâmicos que recebemos por parâmetro no método, e usamos esta sintaxe para utilizarmos o valor deles e não um valor estático.

O resto é bem parecido com SQL, um conhecimento que é bom ter e preciso estudar mais sobre, além de estudar o JPA e o JPQL em si.

É importante lembrar que quando precisamos fazer uma filtragem diferente dos registros no banco para conseguirmos uma ou mais instâncias de entidades, também podemos fazer a lógica no próprio Java, mas isso não é uma boa prática, levando em conta que os bancos de dados já são muito mais otimizados para aplicar esses filtros, assim se tornando uma boa prática realizar esta filtragem a partir da query no banco mesmo.
